# Вариант 7. Имитация отжига для TSP
Задача: реализовать метаэвристику имитация отжига для решения задачи коммивояжера.
Требования:
- Параметры: начальная температура, коэффициент охлаждения, количество итераций
- Использовать 2-opt обмен для построения соседних решений
- Вывести найденный маршрут и его стоимость
- Вывести количество улучшений на различных температурах
Входные данные:
Та же матрица расстояний для 8 городов
Начальная температура: 100
Коэффициент охлаждения: 0.95

# Описание алгоритма
Алгоритм, представленный в коде, решает известную задачу коммивояжера (Travelling Salesman Problem, TSP). Задача заключается в поиске оптимального пути, проходящего через заданное количество городов ровно один раз и возвращающегося обратно в исходный пункт, минимизируя общую длину пройденного маршрута.

С помощью const vector<vector<int>> dist = {...} создаётся матрица, которая определяет расстояние между всеми парами городов. Функция calculateCost() вычисляет суммарную длину маршрута путем последовательного суммирования расстояний между каждой парой соседних городов в маршруте с помощью цикла for (int i = 0; i < n; ++i). Важно отметить, что последняя точка соединяется снова с первой точкой для завершения цикла. Метод twoOptSwap() реализует технику локального улучшения путём замены пары рёбер в маршруте с помощью встроенной функции reverse(). Это улучшает маршрут за счёт сокращения длины путей, соединяющих промежуточные города. Функция getNeighbor() генерирует новый маршрут путём случайного выбора двух точек в существующем маршруте и применения операции 2-opt свопа. Таким образом создаётся новый потенциальный путь, близкий к предыдущему маршруту. Имитация отжига (Simulated Annealing) - это основной алгоритм оптимизации, используемый для решения проблемы TSP. Алгоритм имитирует процесс охлаждения металла, начиная с высокой температуры (параметр initialTemp), постепенно уменьшая её на каждом этапе (через коэффициент coolingRate). Алгоритм использует все вышеописанные функции.

# Временная сложность:
O(N*I), где: N— размер исходной матрицы (количество городов), I — количество итераций (обычно задано константой)

# Объяснение временной сложности:
Временная сложность алгоритма симулированного отжига для задачи коммивояжера выражается формулой O(N*I), поскольку каждая из I итераций включает создание нового маршрута и расчёт его стоимости за время O(N).

# Ответ на контрольный вопрос №7:
def interval_scheduling(intervals):
    intervals.sort(key=lambda x: x[1])  
    result = []                        
    last_end = float('-inf')    
    
    for start, end in intervals:    
        if start >= last_end:           # если начало нового интервала ≥ конца последнего выбранного
            result.append((start, end)) # добавляем интервал в результат
            last_end = end              # обновляем конец последнего выбранного интервала   
            
    return result
