#include <iostream>
#include <vector>
#include <random>
#include <cmath>
#include <algorithm>
#include <iomanip>

using namespace std;

// Матрица расстояний (8 городов)
const vector<vector<int>> dist = {
    {0,  10, 15, 20, 12, 8,  25, 30},
    {10, 0,  18, 14, 9,  11, 22, 27},
    {15, 18, 0,  16, 17, 20, 24, 29},
    {20, 14, 16, 0,  21, 19, 23, 28},
    {12, 9,  17, 21, 0,  13, 18, 26},
    {8,  11, 20, 19, 13, 0,  15, 24},
    {25, 22, 24, 23, 18, 15, 0,  12},
    {30, 27, 29, 28, 26, 24, 12, 0}
};

// Вычисление стоимости маршрута
int calculateCost(const vector<int>& route) {
    int cost = 0;
    int n = route.size();
    for (int i = 0; i < n; ++i) {
        cost += dist[route[i]][route[(i + 1) % n]];
    }
    return cost;
}

// 2-opt обмен: меняем два ребра
vector<int> twoOptSwap(const vector<int>& route, int i, int j) {
    vector<int> newRoute = route;
    reverse(newRoute.begin() + i, newRoute.begin() + j + 1);
    return newRoute;
}

// Генерация случайного соседа через 2-opt
vector<int> getNeighbor(const vector<int>& currentRoute, mt19937& gen) {
    int n = currentRoute.size();
    uniform_int_distribution<int> dis(1, n - 1); // избегаем 0 (старт)
    int i = dis(gen);
    int j = dis(gen);
    if (i > j) swap(i, j);
    if (i == j) j = (j + 1) % n;
    return twoOptSwap(currentRoute, i, j);
}

// Имитация отжига для TSP
void simulatedAnnealing(int initialTemp, double coolingRate, int maxIterations) {
    int n = dist.size();
    mt19937 gen(random_device{}());
    
    // Начальный маршрут: 0 -> 1 -> ... -> n-1 -> 0
    vector<int> currentRoute(n);
    for (int i = 0; i < n; ++i) currentRoute[i] = i;
    
    int currentCost = calculateCost(currentRoute);
    vector<int> bestRoute = currentRoute;
    int bestCost = currentCost;
    
    double temp = initialTemp;
    int improvements = 0;
    
    cout << "Начальный маршрут: ";
    for (int city : currentRoute) cout << city << " ";
    cout << "\nНачальная стоимость: " << currentCost << "\n";
    
    for (int iter = 0; iter < maxIterations; ++iter) {
        // Генерируем соседа
        vector<int> neighbor = getNeighbor(currentRoute, gen);
        int neighborCost = calculateCost(neighbor);
        
        // Разница в стоимости
        int delta = neighborCost - currentCost;
        
        //  Принимаем решение по критерию Метropolis
        if (delta < 0 || exp(-delta / temp) > uniform_real_distribution<double>(0.0, 1.0)(gen)) {
            currentRoute = neighbor;
            currentCost = neighborCost;
            
            if (currentCost < bestCost) {
                bestRoute = currentRoute;
                bestCost = currentCost;
                improvements++;
            }
        }
        
        // Охлаждение
        temp *= coolingRate;
    }
    
    // Вывод результата
    cout << "\nНайденный маршрут: ";
    for (int city : bestRoute) cout << city << " ";
    cout << "0"; // возврат в стартовый город
    cout << "\nСтоимость маршрута: " << bestCost << "\n";
    cout << "Количество улучшений: " << improvements << "\n";
}

int main() {
    const int initialTemp = 100;
    const double coolingRate = 0.95;
    const int maxIterations = 10000;
    
    simulatedAnnealing(initialTemp, coolingRate, maxIterations);
    
    return 0;
}



Начальный маршрут: 0 1 2 3 4 5 6 7 
Начальная стоимость: 135

Найденный маршрут: 0 5 6 7 4 1 3 2 0
Стоимость маршрута: 115
Количество улучшений: 3
