# УСЛОВИЕ

Задание 20. Имитация отжига для задачи размещения центров
Условие. Разместить k центров на плоскости так, чтобы минимизировать суммарное
расстояние от каждой из n точек‑клиентов до ближайшего центра.
Алгоритм: имитация отжига: случайное смещение центров, принятие решения по критерию
Метрополиса.


Язык примера: C++
```
vector<pair<double, double>> sa_facility_location(
 const vector<pair<double, double>>& clients,
 int k, double temp, double cooling
) {
 // Инициализация: случайные позиции k центров
 vector<pair<double, double>> centers(k);
 for (int i = 0; i < k; i++) {
 centers[i] = {
 random_double(-10, 10),
 random_double(-10, 10)
 };
 }
 double current_cost = totalDistance(clients, centers);
 while (temp > 1e-6) {
 // Создаём кандидата: сдвигаем один случайный центр
 vector<pair<double, double>> new_centers = centers;
 int idx = random_int(0, k - 1);
 new_centers[idx].first += random_double(-1, 1) * temp;
 new_centers[idx].second += random_double(-1, 1) * temp;
 double new_cost = totalDistance(clients, new_centers);
 // ДОПИСАТЬ: принять/отклонить new_centers по критерию Метрополиса
 // Если принято, обновить centers и current_cost
 temp *= cooling;
 }
 return centers;
}
```


Что дописать:
1. Условие принятия нового решения:
o если new_cost < current_cost, принимаем;
o иначе принимаем с вероятностью exp((current_cost - new_cost)/temp).
2. Обновление centers и current_cost при принятии.

   
Примечания:
• Функция totalDistance считает сумму расстояний от каждого клиента до
ближайшего центра.
• random_double(a, b) возвращает случайное число из [a,b].
• random_int(a, b) возвращает случайное целое из [a,b].


# Объяснение алгоритма
Задача состоит в размещении заданного количества центров ( $k$ ) таким образом, чтобы минимизировать среднее расстояние от каждого клиента до ближайшего центра. Для её решения используется метод имитации отжига (simulated annealing). Рассмотрим подробно каждую часть программы и принцип работы алгоритма.


**Основные компоненты программы:**


1) Генерация случайных чисел:
```
random_device rd;
mt19937 gen(rd());
```


3) Функция totalDistance вычисляет сумму расстояний от каждого клиента до ближайшего центра по формуле:

 d_{\text{total}} = \sum_{i=1}^{n}\min_j(\sqrt{(x_i-x_j)^2+(y_i-y_j)^2})

   Где $(x_i,y_i)$ — координаты $i$-го клиента, а $(x_j,y_j)$ — координаты возможных центров.


3) Инициализация центров:
Центры случайно распределяются в пределах прямоугольника размером -10 до +10.

```
vector<pair<double, double>> centers(k);
for (int i = 0; i < k; i++)
...
```


5) Основной цикл отжига:
Начинается с начальной температуры (temp) и постепенно понижается (охлаждается) с помощью цикла while (temp > 1e-6).

Каждая итерация включает два шага:
1. Случайно выбирается один из центров и слегка смещается в случайном направлении (шаг пропорционален температуре).
```
vector<pair<double, double>> new_centers = centers;
int idx = random_int(0, k - 1);
new_centers[idx].first += random_double(-1, 1) * temp;
new_centers[idx].second += random_double(-1, 1) * temp;
```

2. Рассчитывается новая общая стоимость расположения центров (суммарное расстояние) по критерию Метрополиса.

Если новое расположение улучшает общую стоимость, оно принимается безусловно.
```
if (new_cost < current_cost) {
// Принимаем улучшение однозначно
centers = new_centers;
current_cost = new_cost;
```
Если же новая позиция хуже предыдущей, она принимается с некоторой вероятностью, зависящей от разницы в стоимости и текущей температуры.
```
// Вычисляем вероятность принятия ухудшения
double delta = new_cost - current_cost;
double probability = exp(-delta / temp);
```




5) Охлаждение:
Температура уменьшается на каждом шаге согласно заданному коэффициенту охлаждения (cooling, например, $0.99$ ), пока не станет достаточно низкой ( $\approx 10^{-6}$ ).



6) Финальный вывод результатов:
После завершения цикла программа выводит оптимизированные позиции центров и итоговую минимизированную сумму расстояний.




**Итоговый вывод:**

Программа реализует алгоритм имитации отжига для оптимального размещения центров, минимизируя суммарное расстояние от клиентов до ближайшей точки обслуживания. Этот подход эффективен для сложных оптимизационных задач, где существует риск застревания в локальном минимуме, благодаря возможности временно ухудшать решение с небольшой вероятностью.


# Временная сложность: O(m·n·k)
где:
m — количество шагов охлаждений,
n — количество клиентов,
k — количество центров.

# Объяснение временной сложности:
Общий порядок сложности получается O(m·n·k), поскольку мы делаем m шагов охлаждения, на каждом шаге рассчитываем сумму расстояний для всех n клиентов и k центров.
