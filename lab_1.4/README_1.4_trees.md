# Общий алгоритм работы с деревьями

**Независимо от выбранного языка программирования общий подход остается неизменным:**
- Дерево представляет собой иерархическую структуру, состоящую из узлов (вершин), каждый из которых хранит данные и ссылки на дочерние узлы.
- Операции включают создание дерева, вставку новых элементов, поиск существующих значений, обход дерева различными способами (пред-порядок, прямой порядок, пост-порядок) и удаление узлов.

**Эти операции реализуются одинаково независимо от языка, и ключевые шаги совпадают:**
- Вставка осуществляется путем нахождения подходящего места в дереве исходя из порядка сортировки (ключ меньший — слева, больший — справа).
- Обход дерева включает обработку всех узлов в определенном порядке (например, pre-order или in-order).
- Удаление учитывает случаи наличия детей (листовых узлов, одно-детальных и двух-детальных узлов).

# Сходство и различие
## Python
**Особенности реализации:**
- Динамическая типизация
- Использование ссылок (None для отсутствующих узлов)
- Рекурсивные алгоритмы для обходов
- Простота реализации благодаря сборке мусора

**Алгоритмы:**
- Вставка: итеративный спуск с поиском места
- Поиск пути: рекурсивный DFS с backtracking
- Обходы: рекурсивные DFS и итеративный BFS
  
## C++
**Особенности реализации:**
- Статическая типизация с указателями
- Явное управление памятью (new/delete)
- Использование nullptr вместо NULL
- Шаблонные классы для обобщенности

**Алгоритмы:**
- Вставка: итеративный спуск с двойными указателями
- Деструктор для рекурсивного удаления
- Использование STL контейнеров для путей
  
## Java
**Особенности реализации:**
- Сборка мусора (автоматическое управление памятью)
- Использование null для отсутствующих узлов
- Коллекции Framework для работы с путями
- Дженерики для типобезопасности

**Алгоритмы:**
- Вставка: итеративный спуск с parent tracking
- Использование ArrayList для путей
- Queue интерфейс для BFS

